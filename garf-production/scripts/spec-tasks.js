#!/usr/bin/env node

/**
 * Spec Kit Task Generator
 * Generates development tasks from specifications
 */

const fs = require('fs');
const path = require('path');

const SPECS_DIR = path.join(__dirname, '..', 'specs');
const TASKS_OUTPUT = path.join(__dirname, '..', 'tasks.json');

/**
 * Parse a specification file and extract tasks
 */
function parseSpec(filePath) {
  const content = fs.readFileSync(filePath, 'utf-8');
  const fileName = path.basename(filePath, '.spec.md');
  
  const tasks = [];
  const lines = content.split('\n');
  
  let currentSection = '';
  let requirements = [];
  let successCriteria = [];
  
  for (const line of lines) {
    if (line.startsWith('## ')) {
      currentSection = line.substring(3).trim();
    } else if (currentSection === 'Requirements' && line.trim().match(/^\d+\./)) {
      requirements.push(line.trim());
    } else if (currentSection === 'Success Criteria' && line.trim().startsWith('-')) {
      successCriteria.push(line.trim().substring(1).trim());
    }
  }
  
  // Generate tasks from requirements
  requirements.forEach((req, index) => {
    const requirementText = req.replace(/^\d+\.\s*/, '').replace(/\*\*/g, '');
    const taskName = requirementText.split(':')[0] || requirementText.substring(0, 50);
    
    tasks.push({
      id: `${fileName}-req-${index + 1}`,
      type: 'requirement',
      spec: fileName,
      title: `Implement: ${taskName}`,
      description: requirementText,
      priority: getPriority(requirementText),
      estimation: getEstimation(requirementText),
      labels: ['spec-driven', fileName, 'requirement'],
      status: 'todo'
    });
  });
  
  // Generate tasks from success criteria
  successCriteria.forEach((criteria, index) => {
    tasks.push({
      id: `${fileName}-test-${index + 1}`,
      type: 'test',
      spec: fileName,
      title: `Test: ${criteria.substring(0, 50)}...`,
      description: `Verify: ${criteria}`,
      priority: 'medium',
      estimation: 2,
      labels: ['spec-driven', fileName, 'testing'],
      status: 'todo'
    });
  });
  
  return tasks;
}

/**
 * Determine priority based on keywords
 */
function getPriority(text) {
  const lowercaseText = text.toLowerCase();
  
  if (lowercaseText.includes('critical') || lowercaseText.includes('must')) {
    return 'high';
  } else if (lowercaseText.includes('should') || lowercaseText.includes('important')) {
    return 'medium';
  } else if (lowercaseText.includes('could') || lowercaseText.includes('nice to have')) {
    return 'low';
  }
  
  return 'medium';
}

/**
 * Estimate task complexity in story points
 */
function getEstimation(text) {
  const lowercaseText = text.toLowerCase();
  
  // Simple heuristics for estimation
  if (lowercaseText.includes('complex') || lowercaseText.includes('algorithm')) {
    return 8;
  } else if (lowercaseText.includes('api') || lowercaseText.includes('integration')) {
    return 5;
  } else if (lowercaseText.includes('ui') || lowercaseText.includes('form')) {
    return 3;
  } else if (lowercaseText.includes('validation') || lowercaseText.includes('check')) {
    return 2;
  }
  
  return 3; // Default estimation
}

/**
 * Generate GitHub issue template
 */
function generateGitHubIssue(task) {
  return `
## 📋 Task: ${task.title}

### 📝 Description
${task.description}

### 🎯 Specification
From: \`${task.spec}.spec.md\`

### ⚡ Priority
${task.priority.toUpperCase()}

### 📊 Estimation
${task.estimation} story points

### ✅ Acceptance Criteria
- [ ] Implementation complete
- [ ] Unit tests written
- [ ] Integration tests passing
- [ ] Documentation updated
- [ ] Code reviewed

### 🏷️ Labels
${task.labels.map(l => `\`${l}\``).join(', ')}

---
*Generated by Spec Kit*
`;
}

/**
 * Main execution
 */
function main() {
  console.log('🚀 Generating tasks from specifications...\n');
  
  const specFiles = fs.readdirSync(SPECS_DIR)
    .filter(file => file.endsWith('.spec.md'));
  
  const allTasks = [];
  
  for (const specFile of specFiles) {
    const filePath = path.join(SPECS_DIR, specFile);
    console.log(`📄 Processing: ${specFile}`);
    
    const tasks = parseSpec(filePath);
    allTasks.push(...tasks);
    
    console.log(`   ✅ Generated ${tasks.length} tasks`);
  }
  
  // Save tasks to JSON
  fs.writeFileSync(TASKS_OUTPUT, JSON.stringify(allTasks, null, 2));
  console.log(`\n📁 Saved ${allTasks.length} tasks to tasks.json`);
  
  // Generate GitHub issues markdown
  const issuesDir = path.join(__dirname, '..', 'github-issues');
  if (!fs.existsSync(issuesDir)) {
    fs.mkdirSync(issuesDir);
  }
  
  allTasks.forEach(task => {
    const issueContent = generateGitHubIssue(task);
    const issueFile = path.join(issuesDir, `${task.id}.md`);
    fs.writeFileSync(issueFile, issueContent);
  });
  
  console.log(`📝 Generated ${allTasks.length} GitHub issue templates in github-issues/`);
  
  // Print summary
  console.log('\n📊 Summary:');
  console.log(`   Total Tasks: ${allTasks.length}`);
  console.log(`   High Priority: ${allTasks.filter(t => t.priority === 'high').length}`);
  console.log(`   Medium Priority: ${allTasks.filter(t => t.priority === 'medium').length}`);
  console.log(`   Low Priority: ${allTasks.filter(t => t.priority === 'low').length}`);
  console.log(`   Total Story Points: ${allTasks.reduce((sum, t) => sum + t.estimation, 0)}`);
  
  // Calculate sprint planning
  const VELOCITY = 21; // Story points per sprint
  const totalPoints = allTasks.reduce((sum, t) => sum + t.estimation, 0);
  const sprintsNeeded = Math.ceil(totalPoints / VELOCITY);
  
  console.log(`\n📅 Sprint Planning:`);
  console.log(`   Team Velocity: ${VELOCITY} points/sprint`);
  console.log(`   Estimated Sprints: ${sprintsNeeded}`);
  console.log(`   Estimated Duration: ${sprintsNeeded * 2} weeks`);
}

// Run if executed directly
if (require.main === module) {
  main();
}
